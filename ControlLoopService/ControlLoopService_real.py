"""
________________________________________________________________________

:PROJECT: SiLA2_python

*Control Loop Service*

:details: ControlLoopService:
    Allows to control a Qmix Device with a Control Loop

:file:    ControlLoopService_real.py
:authors: Florian Meinicke

:date: (creation)          2020-10-08T09:17:41.395352
:date: (last modification) 2020-10-08T09:17:41.395352

.. note:: Code generated by sila2codegenerator 0.2.0

________________________________________________________________________

**Copyright**:
  This file is provided "AS IS" with NO WARRANTY OF ANY KIND,
  INCLUDING THE WARRANTIES OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.

  For further Information see LICENSE file that comes with this distribution.
________________________________________________________________________
"""

__version__ = "0.1.0"

# import general packages
import logging
import time         # used for observables
import uuid         # used for observables
import grpc         # used for type hinting only

# import SiLA2 library
import sila2lib.framework.SiLAFramework_pb2 as silaFW_pb2

# import SiLA errors
from qmix_error import SiLAFrameworkError, SiLAFrameworkErrorType

# import gRPC modules for this feature
from .gRPC import ControlLoopService_pb2 as ControlLoopService_pb2
# from .gRPC import ControlLoopService_pb2_grpc as ControlLoopService_pb2_grpc

# import default arguments
from .ControlLoopService_default_arguments import default_dict

from qmixsdk.qmixcontroller import ControllerChannel

# noinspection PyPep8Naming,PyUnusedLocal
class ControlLoopServiceReal:
    """
    Implementation of the *Control Loop Service* in *Real* mode
        The SiLA 2 driver for Qmix Control Devices
    """

    def __init__(self, controller: ControllerChannel):
        """
        Class initialiser

        :param controller: The Qmix Control Channel device
        """

        logging.debug('Started server in mode: {mode}'.format(mode='Real'))

        self.controller = controller
        self.loop_run_uuid: silaFW_pb2.CommandExecutionUUID = None

    def WriteSetPoint(self, request, context: grpc.ServicerContext) \
            -> ControlLoopService_pb2.WriteSetPoint_Responses:
        """
        Executes the unobservable command "Write Set Point"
            Write a Set Point value to the Controller Device

        :param request: gRPC request containing the parameters passed:
            request.SetPointValue (Set Point Value): The Set Point value to write
        :param context: gRPC :class:`~grpc.ServicerContext` object providing gRPC-specific information

        :returns: The return object defined for the command with the following fields:
            request.EmptyResponse (Empty Response): An empty response data type used if no response is required.
        """

        setpoint = request.SetPointValue.value
        logging.info(f"Writing SetPoint {setpoint} to device")
        self.controller.write_setpoint(setpoint)

        return ControlLoopService_pb2.WriteSetPoint_Responses()


    def RunControlLoop(self, request, context: grpc.ServicerContext) \
            -> silaFW_pb2.CommandConfirmation:
        """
        Executes the observable command "Run Control Loop"
            Run the Control Loop

        :param request: gRPC request containing the parameters passed:
            request.EmptyParameter (Empty Parameter): An empty parameter data type used if no parameter is required.
        :param context: gRPC :class:`~grpc.ServicerContext` object providing gRPC-specific information

        :returns: A command confirmation object with the following information:
            commandId: A command id with which this observable command can be referenced in future calls
            lifetimeOfExecution: The (maximum) lifetime of this command call.
        """

        if self.loop_run_uuid is not None:
            raise SiLAFrameworkError(
                error_type=SiLAFrameworkErrorType.COMMAND_EXECUTION_NOT_ACCEPTED,
                msg="There is a running control loop already. Cannot start a new loop!"
            )

        self.controller.enable_control_loop(True)
        result = ('' if self.controller.is_control_loop_enabled() else 'not ') + 'successful'
        logging.debug(f"Starting control loop with set point {self.controller.get_setpoint()} was {result}")

        # respond with UUID and lifetime of execution
        self.loop_run_uuid = silaFW_pb2.CommandExecutionUUID(value=str(uuid.uuid4()))
        return silaFW_pb2.CommandConfirmation(
            commandExecutionUUID=self.loop_run_uuid
        )

    def RunControlLoop_Info(self, request, context: grpc.ServicerContext) \
            -> silaFW_pb2.ExecutionInfo:
        """
        Returns execution information regarding the command call :meth:`~.RunControlLoop`.

        :param request: A request object with the following properties
            commandId: The UUID of the command executed.
        :param context: gRPC :class:`~grpc.ServicerContext` object providing gRPC-specific information

        :returns: An ExecutionInfo response stream for the command with the following fields:
            commandStatus: Status of the command (enumeration)
            progressInfo: Information on the progress of the command (0 to 1)
            estimatedRemainingTime: Estimate of the remaining time required to run the command
            updatedLifetimeOfExecution: An update on the execution lifetime
        """
        # Get the UUID of the command
        command_uuid = request.value

        if command_uuid != self.loop_run_uuid.value:
            raise SiLAFrameworkError(
                error_type=SiLAFrameworkErrorType.INVALID_COMMAND_EXECUTION_UUID,
                msg="There is no command execution with the given UUID!"
            )

        yield silaFW_pb2.ExecutionInfo(
            commandStatus=silaFW_pb2.ExecutionInfo.CommandStatus.waiting
        )

        # we loop only as long as the command is running
        while self.controller.is_control_loop_enabled():
            yield silaFW_pb2.ExecutionInfo(
                commandStatus=silaFW_pb2.ExecutionInfo.CommandStatus.running
            )

            logging.debug(f"Current controller value: {self.controller.read_actual_value()}")
            logging.debug(f"Device status: {self.controller.read_status()}")
            # we add a small delay to give the client a chance to keep up.
            time.sleep(1)
        else:
            # one last time yield the status
            yield silaFW_pb2.ExecutionInfo(
                commandStatus=silaFW_pb2.ExecutionInfo.CommandStatus.finishedSuccessfully
            )

    def RunControlLoop_Result(self, request, context: grpc.ServicerContext) \
            -> ControlLoopService_pb2.RunControlLoop_Responses:
        """
        Returns the final result of the command call :meth:`~.RunControlLoop`.

        :param request: A request object with the following properties
            CommandExecutionUUID: The UUID of the command executed.
        :param context: gRPC :class:`~grpc.ServicerContext` object providing gRPC-specific information

        :returns: The return object defined for the command with the following fields:
            request.EmptyResponse (Empty Response): An empty response data type used if no response is required.
        """
        return ControlLoopService_pb2.RunControlLoop_Responses()


    def StopControlLoop(self, request, context: grpc.ServicerContext) \
            -> ControlLoopService_pb2.StopControlLoop_Responses:
        """
        Executes the unobservable command "Stop Control Loop"
            Stops the Control Loop (has no effect, if no Loop is currently running)

        :param request: gRPC request containing the parameters passed:
            request.EmptyParameter (Empty Parameter): An empty parameter data type used if no parameter is required.
        :param context: gRPC :class:`~grpc.ServicerContext` object providing gRPC-specific information

        :returns: The return object defined for the command with the following fields:
            request.EmptyResponse (Empty Response): An empty response data type used if no response is required.
        """

        self.controller.enable_control_loop(False)
        self.loop_run_uuid = None

        return ControlLoopService_pb2.StopControlLoop_Responses()

    def Subscribe_ControllerValue(self, request, context: grpc.ServicerContext) \
            -> ControlLoopService_pb2.Subscribe_ControllerValue_Responses:
        """
        Requests the observable property Controller Value
            The actual value from the Device

        :param request: An empty gRPC request object (properties have no parameters)
        :param context: gRPC :class:`~grpc.ServicerContext` object providing gRPC-specific information

        :returns: A response object with the following fields:
            request.ControllerValue (Controller Value): The actual value from the Device
        """
        while True:
            yield ControlLoopService_pb2.Subscribe_ControllerValue_Responses(
                ControllerValue=silaFW_pb2.Real(value=self.controller.read_actual_value())
            )
            time.sleep(0.5) # give client some time to catch up


    def Subscribe_SetPointValue(self, request, context: grpc.ServicerContext) \
            -> ControlLoopService_pb2.Subscribe_SetPointValue_Responses:
        """
        Requests the observable property Set Point Value
            The current SetPoint value of the Device

        :param request: An empty gRPC request object (properties have no parameters)
        :param context: gRPC :class:`~grpc.ServicerContext` object providing gRPC-specific information

        :returns: A response object with the following fields:
            request.SetPointValue (Set Point Value): The current SetPoint value of the Device
        """
        while True:
            yield ControlLoopService_pb2.Subscribe_SetPointValue_Responses(
                SetPointValue=silaFW_pb2.Real(value=self.controller.get_setpoint())
            )
            time.sleep(0.5) # give client some time to catch up

